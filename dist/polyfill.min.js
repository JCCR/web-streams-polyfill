(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.default = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const{ReadableStream:ReadableStream}=_dereq_("./spec/reference-implementation/lib/readable-stream"),{WritableStream:WritableStream}=_dereq_("./spec/reference-implementation/lib/writable-stream"),ByteLengthQueuingStrategy=exports.ByteLengthQueuingStrategy=_dereq_("./spec/reference-implementation/lib/byte-length-queuing-strategy"),CountQueuingStrategy=exports.CountQueuingStrategy=_dereq_("./spec/reference-implementation/lib/count-queuing-strategy"),{TransformStream:TransformStream}=_dereq_("./spec/reference-implementation/lib/transform-stream");exports.TransformStream=TransformStream,exports.WritableStream=WritableStream,exports.ReadableStream=ReadableStream;const interfaces={ReadableStream:ReadableStream,WritableStream:WritableStream,ByteLengthQueuingStrategy:ByteLengthQueuingStrategy,CountQueuingStrategy:CountQueuingStrategy,TransformStream:TransformStream};exports.default=interfaces,"undefined"!=typeof window&&Object.assign(window,...Object.keys(interfaces).filter(e=>!(e in window)).map(e=>({[e]:interfaces[e]})));

},{"./spec/reference-implementation/lib/byte-length-queuing-strategy":8,"./spec/reference-implementation/lib/count-queuing-strategy":9,"./spec/reference-implementation/lib/readable-stream":12,"./spec/reference-implementation/lib/transform-stream":13,"./spec/reference-implementation/lib/writable-stream":15}],2:[function(_dereq_,module,exports){
(function (global){
"use strict";function compare(e,t){if(e===t)return 0;for(var r=e.length,n=t.length,i=0,a=Math.min(r,n);i<a;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0}function isBuffer(e){return global.Buffer&&"function"==typeof global.Buffer.isBuffer?global.Buffer.isBuffer(e):!(null==e||!e._isBuffer)}function pToString(e){return Object.prototype.toString.call(e)}function isView(e){return!isBuffer(e)&&("function"==typeof global.ArrayBuffer&&("function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(e):!!e&&(e instanceof DataView||!!(e.buffer&&e.buffer instanceof ArrayBuffer))))}function getName(e){if(util.isFunction(e)){if(functionsHaveNames)return e.name;var t=e.toString().match(regex);return t&&t[1]}}function truncate(e,t){return"string"==typeof e?e.length<t?e:e.slice(0,t):e}function inspect(e){if(functionsHaveNames||!util.isFunction(e))return util.inspect(e);var t=getName(e);return"[Function"+(t?": "+t:"")+"]"}function getMessage(e){return truncate(inspect(e.actual),128)+" "+e.operator+" "+truncate(inspect(e.expected),128)}function fail(e,t,r,n,i){throw new assert.AssertionError({message:r,actual:e,expected:t,operator:n,stackStartFunction:i})}function ok(e,t){e||fail(e,!0,t,"==",assert.ok)}function _deepEqual(e,t,r,n){if(e===t)return!0;if(isBuffer(e)&&isBuffer(t))return 0===compare(e,t);if(util.isDate(e)&&util.isDate(t))return e.getTime()===t.getTime();if(util.isRegExp(e)&&util.isRegExp(t))return e.source===t.source&&e.global===t.global&&e.multiline===t.multiline&&e.lastIndex===t.lastIndex&&e.ignoreCase===t.ignoreCase;if(null!==e&&"object"==typeof e||null!==t&&"object"==typeof t){if(isView(e)&&isView(t)&&pToString(e)===pToString(t)&&!(e instanceof Float32Array||e instanceof Float64Array))return 0===compare(new Uint8Array(e.buffer),new Uint8Array(t.buffer));if(isBuffer(e)!==isBuffer(t))return!1;var i=(n=n||{actual:[],expected:[]}).actual.indexOf(e);return-1!==i&&i===n.expected.indexOf(t)||(n.actual.push(e),n.expected.push(t),objEquiv(e,t,r,n))}return r?e===t:e==t}function isArguments(e){return"[object Arguments]"==Object.prototype.toString.call(e)}function objEquiv(e,t,r,n){if(null===e||void 0===e||null===t||void 0===t)return!1;if(util.isPrimitive(e)||util.isPrimitive(t))return e===t;if(r&&Object.getPrototypeOf(e)!==Object.getPrototypeOf(t))return!1;var i=isArguments(e),a=isArguments(t);if(i&&!a||!i&&a)return!1;if(i)return e=pSlice.call(e),t=pSlice.call(t),_deepEqual(e,t,r);var s,o,u=objectKeys(e),f=objectKeys(t);if(u.length!==f.length)return!1;for(u.sort(),f.sort(),o=u.length-1;o>=0;o--)if(u[o]!==f[o])return!1;for(o=u.length-1;o>=0;o--)if(s=u[o],!_deepEqual(e[s],t[s],r,n))return!1;return!0}function notDeepStrictEqual(e,t,r){_deepEqual(e,t,!0)&&fail(e,t,r,"notDeepStrictEqual",notDeepStrictEqual)}function expectedException(e,t){if(!e||!t)return!1;if("[object RegExp]"==Object.prototype.toString.call(t))return t.test(e);try{if(e instanceof t)return!0}catch(e){}return!Error.isPrototypeOf(t)&&!0===t.call({},e)}function _tryBlock(e){var t;try{e()}catch(e){t=e}return t}function _throws(e,t,r,n){var i;if("function"!=typeof t)throw new TypeError('"block" argument must be a function');"string"==typeof r&&(n=r,r=null),i=_tryBlock(t),n=(r&&r.name?" ("+r.name+").":".")+(n?" "+n:"."),e&&!i&&fail(i,r,"Missing expected exception"+n);var a="string"==typeof n,s=!e&&util.isError(i),o=!e&&i&&!r;if((s&&a&&expectedException(i,r)||o)&&fail(i,r,"Got unwanted exception"+n),e&&i&&r&&!expectedException(i,r)||!e&&i)throw i}var util=_dereq_("util/"),hasOwn=Object.prototype.hasOwnProperty,pSlice=Array.prototype.slice,functionsHaveNames="foo"===function(){}.name,assert=module.exports=ok,regex=/\s*function\s+([^\(\s]*)\s*/;assert.AssertionError=function(e){this.name="AssertionError",this.actual=e.actual,this.expected=e.expected,this.operator=e.operator,e.message?(this.message=e.message,this.generatedMessage=!1):(this.message=getMessage(this),this.generatedMessage=!0);var t=e.stackStartFunction||fail;if(Error.captureStackTrace)Error.captureStackTrace(this,t);else{var r=new Error;if(r.stack){var n=r.stack,i=getName(t),a=n.indexOf("\n"+i);if(a>=0){var s=n.indexOf("\n",a+1);n=n.substring(s+1)}this.stack=n}}},util.inherits(assert.AssertionError,Error),assert.fail=fail,assert.ok=ok,assert.equal=function(e,t,r){e!=t&&fail(e,t,r,"==",assert.equal)},assert.notEqual=function(e,t,r){e==t&&fail(e,t,r,"!=",assert.notEqual)},assert.deepEqual=function(e,t,r){_deepEqual(e,t,!1)||fail(e,t,r,"deepEqual",assert.deepEqual)},assert.deepStrictEqual=function(e,t,r){_deepEqual(e,t,!0)||fail(e,t,r,"deepStrictEqual",assert.deepStrictEqual)},assert.notDeepEqual=function(e,t,r){_deepEqual(e,t,!1)&&fail(e,t,r,"notDeepEqual",assert.notDeepEqual)},assert.notDeepStrictEqual=notDeepStrictEqual,assert.strictEqual=function(e,t,r){e!==t&&fail(e,t,r,"===",assert.strictEqual)},assert.notStrictEqual=function(e,t,r){e===t&&fail(e,t,r,"!==",assert.notStrictEqual)},assert.throws=function(e,t,r){_throws(!0,e,t,r)},assert.doesNotThrow=function(e,t,r){_throws(!1,e,t,r)},assert.ifError=function(e){if(e)throw e};var objectKeys=Object.keys||function(e){var t=[];for(var r in e)hasOwn.call(e,r)&&t.push(r);return t};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"util/":7}],3:[function(_dereq_,module,exports){

},{}],4:[function(_dereq_,module,exports){
function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}function runTimeout(e){if(cachedSetTimeout===setTimeout)return setTimeout(e,0);if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout)return cachedSetTimeout=setTimeout,setTimeout(e,0);try{return cachedSetTimeout(e,0)}catch(t){try{return cachedSetTimeout.call(null,e,0)}catch(t){return cachedSetTimeout.call(this,e,0)}}}function runClearTimeout(e){if(cachedClearTimeout===clearTimeout)return clearTimeout(e);if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout)return cachedClearTimeout=clearTimeout,clearTimeout(e);try{return cachedClearTimeout(e)}catch(t){try{return cachedClearTimeout.call(null,e)}catch(t){return cachedClearTimeout.call(this,e)}}}function cleanUpNextTick(){draining&&currentQueue&&(draining=!1,currentQueue.length?queue=currentQueue.concat(queue):queueIndex=-1,queue.length&&drainQueue())}function drainQueue(){if(!draining){var e=runTimeout(cleanUpNextTick);draining=!0;for(var t=queue.length;t;){for(currentQueue=queue,queue=[];++queueIndex<t;)currentQueue&&currentQueue[queueIndex].run();queueIndex=-1,t=queue.length}currentQueue=null,draining=!1,runClearTimeout(e)}}function Item(e,t){this.fun=e,this.array=t}function noop(){}var cachedSetTimeout,cachedClearTimeout,process=module.exports={};!function(){try{cachedSetTimeout="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(e){cachedSetTimeout=defaultSetTimout}try{cachedClearTimeout="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(e){cachedClearTimeout=defaultClearTimeout}}();var currentQueue,queue=[],draining=!1,queueIndex=-1;process.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];queue.push(new Item(e,t)),1!==queue.length||draining||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},process.title="browser",process.browser=!0,process.env={},process.argv=[],process.version="",process.versions={},process.on=noop,process.addListener=noop,process.once=noop,process.off=noop,process.removeListener=noop,process.removeAllListeners=noop,process.emit=noop,process.prependListener=noop,process.prependOnceListener=noop,process.listeners=function(e){return[]},process.binding=function(e){throw new Error("process.binding is not supported")},process.cwd=function(){return"/"},process.chdir=function(e){throw new Error("process.chdir is not supported")},process.umask=function(){return 0};

},{}],5:[function(_dereq_,module,exports){
"function"==typeof Object.create?module.exports=function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})}:module.exports=function(t,e){t.super_=e;var o=function(){};o.prototype=e.prototype,t.prototype=new o,t.prototype.constructor=t};

},{}],6:[function(_dereq_,module,exports){
module.exports=function(o){return o&&"object"==typeof o&&"function"==typeof o.copy&&"function"==typeof o.fill&&"function"==typeof o.readUInt8};

},{}],7:[function(_dereq_,module,exports){
(function (process,global){
function inspect(e,r){var t={seen:[],stylize:stylizeNoColor};return arguments.length>=3&&(t.depth=arguments[2]),arguments.length>=4&&(t.colors=arguments[3]),isBoolean(r)?t.showHidden=r:r&&exports._extend(t,r),isUndefined(t.showHidden)&&(t.showHidden=!1),isUndefined(t.depth)&&(t.depth=2),isUndefined(t.colors)&&(t.colors=!1),isUndefined(t.customInspect)&&(t.customInspect=!0),t.colors&&(t.stylize=stylizeWithColor),formatValue(t,e,t.depth)}function stylizeWithColor(e,r){var t=inspect.styles[r];return t?"["+inspect.colors[t][0]+"m"+e+"["+inspect.colors[t][1]+"m":e}function stylizeNoColor(e,r){return e}function arrayToHash(e){var r={};return e.forEach(function(e,t){r[e]=!0}),r}function formatValue(e,r,t){if(e.customInspect&&r&&isFunction(r.inspect)&&r.inspect!==exports.inspect&&(!r.constructor||r.constructor.prototype!==r)){var n=r.inspect(t,e);return isString(n)||(n=formatValue(e,n,t)),n}var i=formatPrimitive(e,r);if(i)return i;var o=Object.keys(r),s=arrayToHash(o);if(e.showHidden&&(o=Object.getOwnPropertyNames(r)),isError(r)&&(o.indexOf("message")>=0||o.indexOf("description")>=0))return formatError(r);if(0===o.length){if(isFunction(r)){var u=r.name?": "+r.name:"";return e.stylize("[Function"+u+"]","special")}if(isRegExp(r))return e.stylize(RegExp.prototype.toString.call(r),"regexp");if(isDate(r))return e.stylize(Date.prototype.toString.call(r),"date");if(isError(r))return formatError(r)}var c="",a=!1,l=["{","}"];if(isArray(r)&&(a=!0,l=["[","]"]),isFunction(r)&&(c=" [Function"+(r.name?": "+r.name:"")+"]"),isRegExp(r)&&(c=" "+RegExp.prototype.toString.call(r)),isDate(r)&&(c=" "+Date.prototype.toUTCString.call(r)),isError(r)&&(c=" "+formatError(r)),0===o.length&&(!a||0==r.length))return l[0]+c+l[1];if(t<0)return isRegExp(r)?e.stylize(RegExp.prototype.toString.call(r),"regexp"):e.stylize("[Object]","special");e.seen.push(r);var p;return p=a?formatArray(e,r,t,s,o):o.map(function(n){return formatProperty(e,r,t,s,n,a)}),e.seen.pop(),reduceToSingleString(p,c,l)}function formatPrimitive(e,r){if(isUndefined(r))return e.stylize("undefined","undefined");if(isString(r)){var t="'"+JSON.stringify(r).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(t,"string")}return isNumber(r)?e.stylize(""+r,"number"):isBoolean(r)?e.stylize(""+r,"boolean"):isNull(r)?e.stylize("null","null"):void 0}function formatError(e){return"["+Error.prototype.toString.call(e)+"]"}function formatArray(e,r,t,n,i){for(var o=[],s=0,u=r.length;s<u;++s)hasOwnProperty(r,String(s))?o.push(formatProperty(e,r,t,n,String(s),!0)):o.push("");return i.forEach(function(i){i.match(/^\d+$/)||o.push(formatProperty(e,r,t,n,i,!0))}),o}function formatProperty(e,r,t,n,i,o){var s,u,c;if((c=Object.getOwnPropertyDescriptor(r,i)||{value:r[i]}).get?u=c.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):c.set&&(u=e.stylize("[Setter]","special")),hasOwnProperty(n,i)||(s="["+i+"]"),u||(e.seen.indexOf(c.value)<0?(u=isNull(t)?formatValue(e,c.value,null):formatValue(e,c.value,t-1)).indexOf("\n")>-1&&(u=o?u.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+u.split("\n").map(function(e){return"   "+e}).join("\n")):u=e.stylize("[Circular]","special")),isUndefined(s)){if(o&&i.match(/^\d+$/))return u;(s=JSON.stringify(""+i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(s=s.substr(1,s.length-2),s=e.stylize(s,"name")):(s=s.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),s=e.stylize(s,"string"))}return s+": "+u}function reduceToSingleString(e,r,t){var n=0;return e.reduce(function(e,r){return n++,r.indexOf("\n")>=0&&n++,e+r.replace(/\u001b\[\d\d?m/g,"").length+1},0)>60?t[0]+(""===r?"":r+"\n ")+" "+e.join(",\n  ")+" "+t[1]:t[0]+r+" "+e.join(", ")+" "+t[1]}function isArray(e){return Array.isArray(e)}function isBoolean(e){return"boolean"==typeof e}function isNull(e){return null===e}function isNullOrUndefined(e){return null==e}function isNumber(e){return"number"==typeof e}function isString(e){return"string"==typeof e}function isSymbol(e){return"symbol"==typeof e}function isUndefined(e){return void 0===e}function isRegExp(e){return isObject(e)&&"[object RegExp]"===objectToString(e)}function isObject(e){return"object"==typeof e&&null!==e}function isDate(e){return isObject(e)&&"[object Date]"===objectToString(e)}function isError(e){return isObject(e)&&("[object Error]"===objectToString(e)||e instanceof Error)}function isFunction(e){return"function"==typeof e}function isPrimitive(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e}function objectToString(e){return Object.prototype.toString.call(e)}function pad(e){return e<10?"0"+e.toString(10):e.toString(10)}function timestamp(){var e=new Date,r=[pad(e.getHours()),pad(e.getMinutes()),pad(e.getSeconds())].join(":");return[e.getDate(),months[e.getMonth()],r].join(" ")}function hasOwnProperty(e,r){return Object.prototype.hasOwnProperty.call(e,r)}var formatRegExp=/%[sdj%]/g;exports.format=function(e){if(!isString(e)){for(var r=[],t=0;t<arguments.length;t++)r.push(inspect(arguments[t]));return r.join(" ")}for(var t=1,n=arguments,i=n.length,o=String(e).replace(formatRegExp,function(e){if("%%"===e)return"%";if(t>=i)return e;switch(e){case"%s":return String(n[t++]);case"%d":return Number(n[t++]);case"%j":try{return JSON.stringify(n[t++])}catch(e){return"[Circular]"}default:return e}}),s=n[t];t<i;s=n[++t])isNull(s)||!isObject(s)?o+=" "+s:o+=" "+inspect(s);return o},exports.deprecate=function(e,r){if(isUndefined(global.process))return function(){return exports.deprecate(e,r).apply(this,arguments)};if(!0===process.noDeprecation)return e;var t=!1;return function(){if(!t){if(process.throwDeprecation)throw new Error(r);process.traceDeprecation?console.trace(r):console.error(r),t=!0}return e.apply(this,arguments)}};var debugEnviron,debugs={};exports.debuglog=function(e){if(isUndefined(debugEnviron)&&(debugEnviron=process.env.NODE_DEBUG||""),e=e.toUpperCase(),!debugs[e])if(new RegExp("\\b"+e+"\\b","i").test(debugEnviron)){var r=process.pid;debugs[e]=function(){var t=exports.format.apply(exports,arguments);console.error("%s %d: %s",e,r,t)}}else debugs[e]=function(){};return debugs[e]},exports.inspect=inspect,inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},inspect.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},exports.isArray=isArray,exports.isBoolean=isBoolean,exports.isNull=isNull,exports.isNullOrUndefined=isNullOrUndefined,exports.isNumber=isNumber,exports.isString=isString,exports.isSymbol=isSymbol,exports.isUndefined=isUndefined,exports.isRegExp=isRegExp,exports.isObject=isObject,exports.isDate=isDate,exports.isError=isError,exports.isFunction=isFunction,exports.isPrimitive=isPrimitive,exports.isBuffer=_dereq_("./support/isBuffer");var months=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];exports.log=function(){console.log("%s - %s",timestamp(),exports.format.apply(exports,arguments))},exports.inherits=_dereq_("inherits"),exports._extend=function(e,r){if(!r||!isObject(r))return e;for(var t=Object.keys(r),n=t.length;n--;)e[t[n]]=r[t[n]];return e};

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":6,"_process":4,"inherits":5}],8:[function(_dereq_,module,exports){
"use strict";const{createDataProperty:createDataProperty}=_dereq_("./helpers.js");module.exports=class{constructor({highWaterMark:e}){createDataProperty(this,"highWaterMark",e)}size(e){return e.byteLength}};

},{"./helpers.js":10}],9:[function(_dereq_,module,exports){
"use strict";const{createDataProperty:createDataProperty}=_dereq_("./helpers.js");module.exports=class{constructor({highWaterMark:r}){createDataProperty(this,"highWaterMark",r)}size(){return 1}};

},{"./helpers.js":10}],10:[function(_dereq_,module,exports){
"use strict";function IsPropertyKey(e){return"string"==typeof e||"symbol"==typeof e}function Call(e,r,t){if("function"!=typeof e)throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,r,t)}const assert=_dereq_("better-assert"),isFakeDetached=Symbol('is "detached" for our purposes');exports.typeIsObject=(e=>"object"==typeof e&&null!==e||"function"==typeof e),exports.createDataProperty=((e,r,t)=>{Object.defineProperty(e,r,{value:t,writable:!0,enumerable:!0,configurable:!0})}),exports.createArrayFromList=(e=>e.slice()),exports.ArrayBufferCopy=((e,r,t,o,a)=>{new Uint8Array(e).set(new Uint8Array(t,o,a),r)}),exports.CreateIterResultObject=((e,r)=>{const t={};return Object.defineProperty(t,"value",{value:e,enumerable:!0,writable:!0,configurable:!0}),Object.defineProperty(t,"done",{value:r,enumerable:!0,writable:!0,configurable:!0}),t}),exports.IsFiniteNonNegativeNumber=(e=>!Number.isNaN(e)&&(e!==1/0&&!(e<0))),exports.Call=Call,exports.InvokeOrNoop=((e,r,t)=>{const o=e[r];if(void 0!==o)return Call(o,e,t)}),exports.PromiseInvokeOrNoop=((e,r,t)=>{try{return Promise.resolve(exports.InvokeOrNoop(e,r,t))}catch(e){return Promise.reject(e)}}),exports.TransferArrayBuffer=(e=>{const r=e.slice();return Object.defineProperty(e,"byteLength",{get:()=>0}),e[isFakeDetached]=!0,r}),exports.IsDetachedBuffer=(e=>isFakeDetached in e),exports.ValidateAndNormalizeHighWaterMark=(e=>{if(e=Number(e),Number.isNaN(e)||e<0)throw new RangeError("highWaterMark property of a queuing strategy must be non-negative and non-NaN");return e}),exports.ValidateAndNormalizeQueuingStrategy=((e,r)=>{if(void 0!==e&&"function"!=typeof e)throw new TypeError("size property of a queuing strategy must be a function");return r=exports.ValidateAndNormalizeHighWaterMark(r),{size:e,highWaterMark:r}});

},{"better-assert":16}],11:[function(_dereq_,module,exports){
"use strict";const assert=_dereq_("better-assert"),{IsFiniteNonNegativeNumber:IsFiniteNonNegativeNumber}=_dereq_("./helpers.js");exports.DequeueValue=(e=>{const u=e._queue.shift();return e._queueTotalSize-=u.size,e._queueTotalSize<0&&(e._queueTotalSize=0),u.value}),exports.EnqueueValueWithSize=((e,u,t)=>{if(t=Number(t),!IsFiniteNonNegativeNumber(t))throw new RangeError("Size must be a finite, non-NaN, non-negative number.");e._queue.push({value:u,size:t}),e._queueTotalSize+=t}),exports.PeekQueueValue=(e=>e._queue[0].value),exports.ResetQueue=(e=>{e._queue=[],e._queueTotalSize=0});

},{"./helpers.js":10,"better-assert":16}],12:[function(_dereq_,module,exports){
"use strict";function AcquireReadableStreamBYOBReader(e){return new ReadableStreamBYOBReader(e)}function AcquireReadableStreamDefaultReader(e){return new ReadableStreamDefaultReader(e)}function IsReadableStream(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")}function IsReadableStreamDisturbed(e){return e._disturbed}function IsReadableStreamLocked(e){return void 0!==e._reader}function ReadableStreamTee(e,r){const t=AcquireReadableStreamDefaultReader(e),a={closedOrErrored:!1,canceled1:!1,canceled2:!1,reason1:void 0,reason2:void 0};a.promise=new Promise(e=>{a._resolve=e});const l=create_ReadableStreamTeePullFunction();l._reader=t,l._teeState=a,l._cloneForBranch2=r;const o=create_ReadableStreamTeeBranch1CancelFunction();o._stream=e,o._teeState=a;const n=create_ReadableStreamTeeBranch2CancelFunction();n._stream=e,n._teeState=a;const s=Object.create(Object.prototype);createDataProperty(s,"pull",l),createDataProperty(s,"cancel",o);const d=new ReadableStream(s),i=Object.create(Object.prototype);createDataProperty(i,"pull",l),createDataProperty(i,"cancel",n);const u=new ReadableStream(i);return l._branch1=d._readableStreamController,l._branch2=u._readableStreamController,t._closedPromise.catch(e=>{!0!==a.closedOrErrored&&(ReadableStreamDefaultControllerError(l._branch1,e),ReadableStreamDefaultControllerError(l._branch2,e),a.closedOrErrored=!0)}),[d,u]}function create_ReadableStreamTeePullFunction(){function e(){const{_reader:r,_branch1:t,_branch2:a,_teeState:l}=e;return ReadableStreamDefaultReaderRead(r).then(e=>{const r=e.value;if(!0===e.done&&!1===l.closedOrErrored&&(!1===l.canceled1&&ReadableStreamDefaultControllerClose(t),!1===l.canceled2&&ReadableStreamDefaultControllerClose(a),l.closedOrErrored=!0),!0===l.closedOrErrored)return;const o=r,n=r;!1===l.canceled1&&ReadableStreamDefaultControllerEnqueue(t,o),!1===l.canceled2&&ReadableStreamDefaultControllerEnqueue(a,n)})}return e}function create_ReadableStreamTeeBranch1CancelFunction(){function e(r){const{_stream:t,_teeState:a}=e;if(a.canceled1=!0,a.reason1=r,!0===a.canceled2){const e=ReadableStreamCancel(t,createArrayFromList([a.reason1,a.reason2]));a._resolve(e)}return a.promise}return e}function create_ReadableStreamTeeBranch2CancelFunction(){function e(r){const{_stream:t,_teeState:a}=e;if(a.canceled2=!0,a.reason2=r,!0===a.canceled1){const e=ReadableStreamCancel(t,createArrayFromList([a.reason1,a.reason2]));a._resolve(e)}return a.promise}return e}function ReadableStreamAddReadIntoRequest(e){return new Promise((r,t)=>{const a={_resolve:r,_reject:t};e._reader._readIntoRequests.push(a)})}function ReadableStreamAddReadRequest(e){return new Promise((r,t)=>{const a={_resolve:r,_reject:t};e._reader._readRequests.push(a)})}function ReadableStreamCancel(e,r){return e._disturbed=!0,"closed"===e._state?Promise.resolve(void 0):"errored"===e._state?Promise.reject(e._storedError):(ReadableStreamClose(e),e._readableStreamController[CancelSteps](r).then(()=>void 0))}function ReadableStreamClose(e){e._state="closed";const r=e._reader;if(void 0!==r){if(!0===IsReadableStreamDefaultReader(r)){for(const{_resolve:e}of r._readRequests)e(CreateIterResultObject(void 0,!0));r._readRequests=[]}defaultReaderClosedPromiseResolve(r)}}function ReadableStreamError(e,r){e._state="errored",e._storedError=r;const t=e._reader;if(void 0!==t){if(!0===IsReadableStreamDefaultReader(t)){for(const e of t._readRequests)e._reject(r);t._readRequests=[]}else{for(const e of t._readIntoRequests)e._reject(r);t._readIntoRequests=[]}defaultReaderClosedPromiseReject(t,r),t._closedPromise.catch(()=>{})}}function ReadableStreamFulfillReadIntoRequest(e,r,t){e._reader._readIntoRequests.shift()._resolve(CreateIterResultObject(r,t))}function ReadableStreamFulfillReadRequest(e,r,t){e._reader._readRequests.shift()._resolve(CreateIterResultObject(r,t))}function ReadableStreamGetNumReadIntoRequests(e){return e._reader._readIntoRequests.length}function ReadableStreamGetNumReadRequests(e){return e._reader._readRequests.length}function ReadableStreamHasBYOBReader(e){const r=e._reader;return void 0!==r&&!1!==IsReadableStreamBYOBReader(r)}function ReadableStreamHasDefaultReader(e){const r=e._reader;return void 0!==r&&!1!==IsReadableStreamDefaultReader(r)}function IsReadableStreamBYOBReader(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")}function IsReadableStreamDefaultReader(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readRequests")}function ReadableStreamReaderGenericInitialize(e,r){e._ownerReadableStream=r,r._reader=e,"readable"===r._state?defaultReaderClosedPromiseInitialize(e):"closed"===r._state?defaultReaderClosedPromiseInitializeAsResolved(e):(defaultReaderClosedPromiseInitializeAsRejected(e,r._storedError),e._closedPromise.catch(()=>{}))}function ReadableStreamReaderGenericCancel(e,r){return ReadableStreamCancel(e._ownerReadableStream,r)}function ReadableStreamReaderGenericRelease(e){"readable"===e._ownerReadableStream._state?defaultReaderClosedPromiseReject(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):defaultReaderClosedPromiseResetToRejected(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._closedPromise.catch(()=>{}),e._ownerReadableStream._reader=void 0,e._ownerReadableStream=void 0}function ReadableStreamBYOBReaderRead(e,r){const t=e._ownerReadableStream;return t._disturbed=!0,"errored"===t._state?Promise.reject(t._storedError):ReadableByteStreamControllerPullInto(t._readableStreamController,r)}function ReadableStreamDefaultReaderRead(e){const r=e._ownerReadableStream;return r._disturbed=!0,"closed"===r._state?Promise.resolve(CreateIterResultObject(void 0,!0)):"errored"===r._state?Promise.reject(r._storedError):r._readableStreamController[PullSteps]()}function IsReadableStreamDefaultController(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_underlyingSource")}function ReadableStreamDefaultControllerCallPullIfNeeded(e){!1!==ReadableStreamDefaultControllerShouldCallPull(e)&&(!0!==e._pulling?(e._pulling=!0,PromiseInvokeOrNoop(e._underlyingSource,"pull",[e]).then(()=>{if(e._pulling=!1,!0===e._pullAgain)return e._pullAgain=!1,ReadableStreamDefaultControllerCallPullIfNeeded(e)},r=>{ReadableStreamDefaultControllerErrorIfNeeded(e,r)}).catch(rethrowAssertionErrorRejection)):e._pullAgain=!0)}function ReadableStreamDefaultControllerShouldCallPull(e){const r=e._controlledReadableStream;return!1!==ReadableStreamDefaultControllerCanCloseOrEnqueue(e)&&(!1!==e._started&&(!0===IsReadableStreamLocked(r)&&ReadableStreamGetNumReadRequests(r)>0||ReadableStreamDefaultControllerGetDesiredSize(e)>0))}function ReadableStreamDefaultControllerClose(e){const r=e._controlledReadableStream;e._closeRequested=!0,0===e._queue.length&&ReadableStreamClose(r)}function ReadableStreamDefaultControllerEnqueue(e,r){const t=e._controlledReadableStream;if(!0===IsReadableStreamLocked(t)&&ReadableStreamGetNumReadRequests(t)>0)ReadableStreamFulfillReadRequest(t,r,!1);else{let t=1;if(void 0!==e._strategySize){const a=e._strategySize;try{t=a(r)}catch(r){throw ReadableStreamDefaultControllerErrorIfNeeded(e,r),r}}try{EnqueueValueWithSize(e,r,t)}catch(r){throw ReadableStreamDefaultControllerErrorIfNeeded(e,r),r}}ReadableStreamDefaultControllerCallPullIfNeeded(e)}function ReadableStreamDefaultControllerError(e,r){const t=e._controlledReadableStream;ResetQueue(e),ReadableStreamError(t,r)}function ReadableStreamDefaultControllerErrorIfNeeded(e,r){"readable"===e._controlledReadableStream._state&&ReadableStreamDefaultControllerError(e,r)}function ReadableStreamDefaultControllerGetDesiredSize(e){const r=e._controlledReadableStream._state;return"errored"===r?null:"closed"===r?0:e._strategyHWM-e._queueTotalSize}function ReadableStreamDefaultControllerHasBackpressure(e){return!0!==ReadableStreamDefaultControllerShouldCallPull(e)}function ReadableStreamDefaultControllerCanCloseOrEnqueue(e){const r=e._controlledReadableStream._state;return!1===e._closeRequested&&"readable"===r}function IsReadableByteStreamController(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_underlyingByteSource")}function IsReadableStreamBYOBRequest(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")}function ReadableByteStreamControllerCallPullIfNeeded(e){!1!==ReadableByteStreamControllerShouldCallPull(e)&&(!0!==e._pulling?(e._pulling=!0,PromiseInvokeOrNoop(e._underlyingByteSource,"pull",[e]).then(()=>{e._pulling=!1,!0===e._pullAgain&&(e._pullAgain=!1,ReadableByteStreamControllerCallPullIfNeeded(e))},r=>{"readable"===e._controlledReadableStream._state&&ReadableByteStreamControllerError(e,r)}).catch(rethrowAssertionErrorRejection)):e._pullAgain=!0)}function ReadableByteStreamControllerClearPendingPullIntos(e){ReadableByteStreamControllerInvalidateBYOBRequest(e),e._pendingPullIntos=[]}function ReadableByteStreamControllerCommitPullIntoDescriptor(e,r){let t=!1;"closed"===e._state&&(t=!0);const a=ReadableByteStreamControllerConvertPullIntoDescriptor(r);"default"===r.readerType?ReadableStreamFulfillReadRequest(e,a,t):ReadableStreamFulfillReadIntoRequest(e,a,t)}function ReadableByteStreamControllerConvertPullIntoDescriptor(e){const r=e.bytesFilled,t=e.elementSize;return new e.ctor(e.buffer,e.byteOffset,r/t)}function ReadableByteStreamControllerEnqueueChunkToQueue(e,r,t,a){e._queue.push({buffer:r,byteOffset:t,byteLength:a}),e._queueTotalSize+=a}function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(e,r){const t=r.elementSize,a=r.bytesFilled-r.bytesFilled%t,l=Math.min(e._queueTotalSize,r.byteLength-r.bytesFilled),o=r.bytesFilled+l,n=o-o%t;let s=l,d=!1;n>a&&(s=n-r.bytesFilled,d=!0);const i=e._queue;for(;s>0;){const t=i[0],a=Math.min(s,t.byteLength),l=r.byteOffset+r.bytesFilled;ArrayBufferCopy(r.buffer,l,t.buffer,t.byteOffset,a),t.byteLength===a?i.shift():(t.byteOffset+=a,t.byteLength-=a),e._queueTotalSize-=a,ReadableByteStreamControllerFillHeadPullIntoDescriptor(e,a,r),s-=a}return d}function ReadableByteStreamControllerFillHeadPullIntoDescriptor(e,r,t){ReadableByteStreamControllerInvalidateBYOBRequest(e),t.bytesFilled+=r}function ReadableByteStreamControllerHandleQueueDrain(e){0===e._queueTotalSize&&!0===e._closeRequested?ReadableStreamClose(e._controlledReadableStream):ReadableByteStreamControllerCallPullIfNeeded(e)}function ReadableByteStreamControllerInvalidateBYOBRequest(e){void 0!==e._byobRequest&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=void 0,e._byobRequest=void 0)}function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(e){for(;e._pendingPullIntos.length>0;){if(0===e._queueTotalSize)return;const r=e._pendingPullIntos[0];!0===ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(e,r)&&(ReadableByteStreamControllerShiftPendingPullInto(e),ReadableByteStreamControllerCommitPullIntoDescriptor(e._controlledReadableStream,r))}}function ReadableByteStreamControllerPullInto(e,r){const t=e._controlledReadableStream;let a=1;r.constructor!==DataView&&(a=r.constructor.BYTES_PER_ELEMENT);const l=r.constructor,o={buffer:TransferArrayBuffer(r.buffer),byteOffset:r.byteOffset,byteLength:r.byteLength,bytesFilled:0,elementSize:a,ctor:l,readerType:"byob"};if(e._pendingPullIntos.length>0)return e._pendingPullIntos.push(o),ReadableStreamAddReadIntoRequest(t);if("closed"===t._state){const e=new r.constructor(o.buffer,o.byteOffset,0);return Promise.resolve(CreateIterResultObject(e,!0))}if(e._queueTotalSize>0){if(!0===ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(e,o)){const r=ReadableByteStreamControllerConvertPullIntoDescriptor(o);return ReadableByteStreamControllerHandleQueueDrain(e),Promise.resolve(CreateIterResultObject(r,!1))}if(!0===e._closeRequested){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");return ReadableByteStreamControllerError(e,r),Promise.reject(r)}}e._pendingPullIntos.push(o);const n=ReadableStreamAddReadIntoRequest(t);return ReadableByteStreamControllerCallPullIfNeeded(e),n}function ReadableByteStreamControllerRespondInClosedState(e,r){r.buffer=TransferArrayBuffer(r.buffer);const t=e._controlledReadableStream;if(!0===ReadableStreamHasBYOBReader(t))for(;ReadableStreamGetNumReadIntoRequests(t)>0;)ReadableByteStreamControllerCommitPullIntoDescriptor(t,ReadableByteStreamControllerShiftPendingPullInto(e))}function ReadableByteStreamControllerRespondInReadableState(e,r,t){if(t.bytesFilled+r>t.byteLength)throw new RangeError("bytesWritten out of range");if(ReadableByteStreamControllerFillHeadPullIntoDescriptor(e,r,t),t.bytesFilled<t.elementSize)return;ReadableByteStreamControllerShiftPendingPullInto(e);const a=t.bytesFilled%t.elementSize;if(a>0){const r=t.byteOffset+t.bytesFilled,l=t.buffer.slice(r-a,r);ReadableByteStreamControllerEnqueueChunkToQueue(e,l,0,l.byteLength)}t.buffer=TransferArrayBuffer(t.buffer),t.bytesFilled-=a,ReadableByteStreamControllerCommitPullIntoDescriptor(e._controlledReadableStream,t),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(e)}function ReadableByteStreamControllerRespondInternal(e,r){const t=e._pendingPullIntos[0];if("closed"===e._controlledReadableStream._state){if(0!==r)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");ReadableByteStreamControllerRespondInClosedState(e,t)}else ReadableByteStreamControllerRespondInReadableState(e,r,t)}function ReadableByteStreamControllerShiftPendingPullInto(e){const r=e._pendingPullIntos.shift();return ReadableByteStreamControllerInvalidateBYOBRequest(e),r}function ReadableByteStreamControllerShouldCallPull(e){const r=e._controlledReadableStream;return"readable"===r._state&&(!0!==e._closeRequested&&(!1!==e._started&&(!0===ReadableStreamHasDefaultReader(r)&&ReadableStreamGetNumReadRequests(r)>0||(!0===ReadableStreamHasBYOBReader(r)&&ReadableStreamGetNumReadIntoRequests(r)>0||ReadableByteStreamControllerGetDesiredSize(e)>0))))}function ReadableByteStreamControllerClose(e){const r=e._controlledReadableStream;if(e._queueTotalSize>0)e._closeRequested=!0;else{if(e._pendingPullIntos.length>0&&e._pendingPullIntos[0].bytesFilled>0){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");throw ReadableByteStreamControllerError(e,r),r}ReadableStreamClose(r)}}function ReadableByteStreamControllerEnqueue(e,r){const t=e._controlledReadableStream,a=r.buffer,l=r.byteOffset,o=r.byteLength,n=TransferArrayBuffer(a);!0===ReadableStreamHasDefaultReader(t)?0===ReadableStreamGetNumReadRequests(t)?ReadableByteStreamControllerEnqueueChunkToQueue(e,n,l,o):ReadableStreamFulfillReadRequest(t,new Uint8Array(n,l,o),!1):!0===ReadableStreamHasBYOBReader(t)?(ReadableByteStreamControllerEnqueueChunkToQueue(e,n,l,o),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(e)):ReadableByteStreamControllerEnqueueChunkToQueue(e,n,l,o)}function ReadableByteStreamControllerError(e,r){const t=e._controlledReadableStream;ReadableByteStreamControllerClearPendingPullIntos(e),ResetQueue(e),ReadableStreamError(t,r)}function ReadableByteStreamControllerGetDesiredSize(e){const r=e._controlledReadableStream._state;return"errored"===r?null:"closed"===r?0:e._strategyHWM-e._queueTotalSize}function ReadableByteStreamControllerRespond(e,r){if(r=Number(r),!1===IsFiniteNonNegativeNumber(r))throw new RangeError("bytesWritten must be a finite");ReadableByteStreamControllerRespondInternal(e,r)}function ReadableByteStreamControllerRespondWithNewView(e,r){const t=e._pendingPullIntos[0];if(t.byteOffset+t.bytesFilled!==r.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(t.byteLength!==r.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");t.buffer=r.buffer,ReadableByteStreamControllerRespondInternal(e,r.byteLength)}function streamBrandCheckException(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function readerLockException(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function defaultReaderBrandCheckException(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}function defaultReaderClosedPromiseInitialize(e){e._closedPromise=new Promise((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t})}function defaultReaderClosedPromiseInitializeAsRejected(e,r){e._closedPromise=Promise.reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function defaultReaderClosedPromiseInitializeAsResolved(e){e._closedPromise=Promise.resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function defaultReaderClosedPromiseReject(e,r){e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function defaultReaderClosedPromiseResetToRejected(e,r){e._closedPromise=Promise.reject(r)}function defaultReaderClosedPromiseResolve(e){e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function byobReaderBrandCheckException(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function defaultControllerBrandCheckException(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function byobRequestBrandCheckException(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function byteStreamControllerBrandCheckException(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}function ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(e){try{Promise.prototype.then.call(e,void 0,()=>{})}catch(e){}}const assert=_dereq_("better-assert"),{ArrayBufferCopy:ArrayBufferCopy,CreateIterResultObject:CreateIterResultObject,IsFiniteNonNegativeNumber:IsFiniteNonNegativeNumber,InvokeOrNoop:InvokeOrNoop,IsDetachedBuffer:IsDetachedBuffer,PromiseInvokeOrNoop:PromiseInvokeOrNoop,TransferArrayBuffer:TransferArrayBuffer,ValidateAndNormalizeQueuingStrategy:ValidateAndNormalizeQueuingStrategy,ValidateAndNormalizeHighWaterMark:ValidateAndNormalizeHighWaterMark}=_dereq_("./helpers.js"),{createArrayFromList:createArrayFromList,createDataProperty:createDataProperty,typeIsObject:typeIsObject}=_dereq_("./helpers.js"),{rethrowAssertionErrorRejection:rethrowAssertionErrorRejection}=_dereq_("./utils.js"),{DequeueValue:DequeueValue,EnqueueValueWithSize:EnqueueValueWithSize,ResetQueue:ResetQueue}=_dereq_("./queue-with-sizes.js"),{AcquireWritableStreamDefaultWriter:AcquireWritableStreamDefaultWriter,IsWritableStream:IsWritableStream,IsWritableStreamLocked:IsWritableStreamLocked,WritableStreamAbort:WritableStreamAbort,WritableStreamDefaultWriterCloseWithErrorPropagation:WritableStreamDefaultWriterCloseWithErrorPropagation,WritableStreamDefaultWriterRelease:WritableStreamDefaultWriterRelease,WritableStreamDefaultWriterWrite:WritableStreamDefaultWriterWrite,WritableStreamCloseQueuedOrInFlight:WritableStreamCloseQueuedOrInFlight}=_dereq_("./writable-stream.js"),CancelSteps=Symbol("[[CancelSteps]]"),PullSteps=Symbol("[[PullSteps]]");class ReadableStream{constructor(e={},{size:r,highWaterMark:t}={}){this._state="readable",this._reader=void 0,this._storedError=void 0,this._disturbed=!1,this._readableStreamController=void 0;const a=e.type;if("bytes"===String(a))void 0===t&&(t=0),this._readableStreamController=new ReadableByteStreamController(this,e,t);else{if(void 0!==a)throw new RangeError("Invalid type is specified");void 0===t&&(t=1),this._readableStreamController=new ReadableStreamDefaultController(this,e,r,t)}}get locked(){if(!1===IsReadableStream(this))throw streamBrandCheckException("locked");return IsReadableStreamLocked(this)}cancel(e){return!1===IsReadableStream(this)?Promise.reject(streamBrandCheckException("cancel")):!0===IsReadableStreamLocked(this)?Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")):ReadableStreamCancel(this,e)}getReader({mode:e}={}){if(!1===IsReadableStream(this))throw streamBrandCheckException("getReader");if(void 0===e)return AcquireReadableStreamDefaultReader(this);if("byob"===(e=String(e)))return AcquireReadableStreamBYOBReader(this);throw new RangeError("Invalid mode is specified")}pipeThrough({writable:e,readable:r},t){if(void 0===e||void 0===r)throw new TypeError("readable and writable arguments must be defined");return ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(this.pipeTo(e,t)),r}pipeTo(e,{preventClose:r,preventAbort:t,preventCancel:a}={}){if(!1===IsReadableStream(this))return Promise.reject(streamBrandCheckException("pipeTo"));if(!1===IsWritableStream(e))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));if(r=Boolean(r),t=Boolean(t),a=Boolean(a),!0===IsReadableStreamLocked(this))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));if(!0===IsWritableStreamLocked(e))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));const l=AcquireReadableStreamDefaultReader(this),o=AcquireWritableStreamDefaultWriter(e);let n=!1,s=Promise.resolve();return new Promise((d,i)=>{function u(){return s=Promise.resolve(),!0===n?Promise.resolve():o._readyPromise.then(()=>ReadableStreamDefaultReaderRead(l).then(({value:e,done:r})=>{!0!==r&&(s=WritableStreamDefaultWriterWrite(o,e).catch(()=>{}))})).then(u)}function c(){const e=s;return s.then(()=>e!==s?c():void 0)}function b(e,r,t){"errored"===e._state?t(e._storedError):r.catch(t).catch(rethrowAssertionErrorRejection)}function R(r,t,a){function l(){r().then(()=>f(t,a),e=>f(!0,e)).catch(rethrowAssertionErrorRejection)}!0!==n&&(n=!0,"writable"===e._state&&!1===WritableStreamCloseQueuedOrInFlight(e)?c().then(l):l())}function m(r,t){!0!==n&&(n=!0,"writable"===e._state&&!1===WritableStreamCloseQueuedOrInFlight(e)?c().then(()=>f(r,t)).catch(rethrowAssertionErrorRejection):f(r,t))}function f(e,r){WritableStreamDefaultWriterRelease(o),ReadableStreamReaderGenericRelease(l),e?i(r):d(void 0)}if(b(this,l._closedPromise,r=>{!1===t?R(()=>WritableStreamAbort(e,r),!0,r):m(!0,r)}),b(e,o._closedPromise,e=>{!1===a?R(()=>ReadableStreamCancel(this,e),!0,e):m(!0,e)}),function(e,r,t){"closed"===e._state?t():r.then(t).catch(rethrowAssertionErrorRejection)}(this,l._closedPromise,()=>{!1===r?R(()=>WritableStreamDefaultWriterCloseWithErrorPropagation(o)):m()}),!0===WritableStreamCloseQueuedOrInFlight(e)||"closed"===e._state){const e=new TypeError("the destination writable stream closed before all data could be piped to it");!1===a?R(()=>ReadableStreamCancel(this,e),!0,e):m(!0,e)}u().catch(e=>{s=Promise.resolve(),rethrowAssertionErrorRejection(e)})})}tee(){if(!1===IsReadableStream(this))throw streamBrandCheckException("tee");const e=ReadableStreamTee(this,!1);return createArrayFromList(e)}}module.exports={ReadableStream:ReadableStream,IsReadableStreamDisturbed:IsReadableStreamDisturbed,ReadableStreamDefaultControllerClose:ReadableStreamDefaultControllerClose,ReadableStreamDefaultControllerEnqueue:ReadableStreamDefaultControllerEnqueue,ReadableStreamDefaultControllerError:ReadableStreamDefaultControllerError,ReadableStreamDefaultControllerGetDesiredSize:ReadableStreamDefaultControllerGetDesiredSize,ReadableStreamDefaultControllerHasBackpressure:ReadableStreamDefaultControllerHasBackpressure,ReadableStreamDefaultControllerCanCloseOrEnqueue:ReadableStreamDefaultControllerCanCloseOrEnqueue};class ReadableStreamDefaultReader{constructor(e){if(!1===IsReadableStream(e))throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");if(!0===IsReadableStreamLocked(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");ReadableStreamReaderGenericInitialize(this,e),this._readRequests=[]}get closed(){return!1===IsReadableStreamDefaultReader(this)?Promise.reject(defaultReaderBrandCheckException("closed")):this._closedPromise}cancel(e){return!1===IsReadableStreamDefaultReader(this)?Promise.reject(defaultReaderBrandCheckException("cancel")):void 0===this._ownerReadableStream?Promise.reject(readerLockException("cancel")):ReadableStreamReaderGenericCancel(this,e)}read(){return!1===IsReadableStreamDefaultReader(this)?Promise.reject(defaultReaderBrandCheckException("read")):void 0===this._ownerReadableStream?Promise.reject(readerLockException("read from")):ReadableStreamDefaultReaderRead(this)}releaseLock(){if(!1===IsReadableStreamDefaultReader(this))throw defaultReaderBrandCheckException("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ReadableStreamReaderGenericRelease(this)}}}class ReadableStreamBYOBReader{constructor(e){if(!IsReadableStream(e))throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");if(!1===IsReadableByteStreamController(e._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");if(IsReadableStreamLocked(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");ReadableStreamReaderGenericInitialize(this,e),this._readIntoRequests=[]}get closed(){return IsReadableStreamBYOBReader(this)?this._closedPromise:Promise.reject(byobReaderBrandCheckException("closed"))}cancel(e){return IsReadableStreamBYOBReader(this)?void 0===this._ownerReadableStream?Promise.reject(readerLockException("cancel")):ReadableStreamReaderGenericCancel(this,e):Promise.reject(byobReaderBrandCheckException("cancel"))}read(e){return IsReadableStreamBYOBReader(this)?void 0===this._ownerReadableStream?Promise.reject(readerLockException("read from")):ArrayBuffer.isView(e)?!0===IsDetachedBuffer(e.buffer)?Promise.reject(new TypeError("Cannot read into a view onto a detached ArrayBuffer")):0===e.byteLength?Promise.reject(new TypeError("view must have non-zero byteLength")):ReadableStreamBYOBReaderRead(this,e):Promise.reject(new TypeError("view must be an array buffer view")):Promise.reject(byobReaderBrandCheckException("read"))}releaseLock(){if(!IsReadableStreamBYOBReader(this))throw byobReaderBrandCheckException("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ReadableStreamReaderGenericRelease(this)}}}class ReadableStreamDefaultController{constructor(e,r,t,a){if(!1===IsReadableStream(e))throw new TypeError("ReadableStreamDefaultController can only be constructed with a ReadableStream instance");if(void 0!==e._readableStreamController)throw new TypeError("ReadableStreamDefaultController instances can only be created by the ReadableStream constructor");this._controlledReadableStream=e,this._underlyingSource=r,this._queue=void 0,this._queueTotalSize=void 0,ResetQueue(this),this._started=!1,this._closeRequested=!1,this._pullAgain=!1,this._pulling=!1;const l=ValidateAndNormalizeQueuingStrategy(t,a);this._strategySize=l.size,this._strategyHWM=l.highWaterMark;const o=this,n=InvokeOrNoop(r,"start",[this]);Promise.resolve(n).then(()=>{o._started=!0,ReadableStreamDefaultControllerCallPullIfNeeded(o)},e=>{ReadableStreamDefaultControllerErrorIfNeeded(o,e)}).catch(rethrowAssertionErrorRejection)}get desiredSize(){if(!1===IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException("desiredSize");return ReadableStreamDefaultControllerGetDesiredSize(this)}close(){if(!1===IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException("close");if(!1===ReadableStreamDefaultControllerCanCloseOrEnqueue(this))throw new TypeError("The stream is not in a state that permits close");ReadableStreamDefaultControllerClose(this)}enqueue(e){if(!1===IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException("enqueue");if(!1===ReadableStreamDefaultControllerCanCloseOrEnqueue(this))throw new TypeError("The stream is not in a state that permits enqueue");return ReadableStreamDefaultControllerEnqueue(this,e)}error(e){if(!1===IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException("error");const r=this._controlledReadableStream;if("readable"!==r._state)throw new TypeError(`The stream is ${r._state} and so cannot be errored`);ReadableStreamDefaultControllerError(this,e)}[CancelSteps](e){return ResetQueue(this),PromiseInvokeOrNoop(this._underlyingSource,"cancel",[e])}[PullSteps](){const e=this._controlledReadableStream;if(this._queue.length>0){const r=DequeueValue(this);return!0===this._closeRequested&&0===this._queue.length?ReadableStreamClose(e):ReadableStreamDefaultControllerCallPullIfNeeded(this),Promise.resolve(CreateIterResultObject(r,!1))}const r=ReadableStreamAddReadRequest(e);return ReadableStreamDefaultControllerCallPullIfNeeded(this),r}}class ReadableStreamBYOBRequest{constructor(e,r){if(!1===IsReadableByteStreamController(e))throw new TypeError("Cannot construct a ReadableStreamBYOBRequest without a ReadableByteStreamController");this._associatedReadableByteStreamController=e,this._view=r}get view(){if(!1===IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("view");return this._view}respond(e){if(!1===IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!0===IsDetachedBuffer(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController,e)}respondWithNewView(e){if(!1===IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!ArrayBuffer.isView(e))throw new TypeError("You can only respond with array buffer views");if(!0===IsDetachedBuffer(e.buffer))throw new TypeError("The supplied view's buffer has been detached and so cannot be used as a response");ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController,e)}}class ReadableByteStreamController{constructor(e,r,t){if(!1===IsReadableStream(e))throw new TypeError("ReadableByteStreamController can only be constructed with a ReadableStream instance given a byte source");if(void 0!==e._readableStreamController)throw new TypeError("ReadableByteStreamController instances can only be created by the ReadableStream constructor given a byte source");this._controlledReadableStream=e,this._underlyingByteSource=r,this._pullAgain=!1,this._pulling=!1,ReadableByteStreamControllerClearPendingPullIntos(this),this._queue=this._queueTotalSize=void 0,ResetQueue(this),this._closeRequested=!1,this._started=!1,this._strategyHWM=ValidateAndNormalizeHighWaterMark(t);const a=r.autoAllocateChunkSize;if(void 0!==a&&(!1===Number.isInteger(a)||a<=0))throw new RangeError("autoAllocateChunkSize must be a positive integer");this._autoAllocateChunkSize=a,this._pendingPullIntos=[];const l=this,o=InvokeOrNoop(r,"start",[this]);Promise.resolve(o).then(()=>{l._started=!0,ReadableByteStreamControllerCallPullIfNeeded(l)},r=>{"readable"===e._state&&ReadableByteStreamControllerError(l,r)}).catch(rethrowAssertionErrorRejection)}get byobRequest(){if(!1===IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("byobRequest");if(void 0===this._byobRequest&&this._pendingPullIntos.length>0){const e=this._pendingPullIntos[0],r=new Uint8Array(e.buffer,e.byteOffset+e.bytesFilled,e.byteLength-e.bytesFilled);this._byobRequest=new ReadableStreamBYOBRequest(this,r)}return this._byobRequest}get desiredSize(){if(!1===IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("desiredSize");return ReadableByteStreamControllerGetDesiredSize(this)}close(){if(!1===IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("close");if(!0===this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const e=this._controlledReadableStream._state;if("readable"!==e)throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);ReadableByteStreamControllerClose(this)}enqueue(e){if(!1===IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("enqueue");if(!0===this._closeRequested)throw new TypeError("stream is closed or draining");const r=this._controlledReadableStream._state;if("readable"!==r)throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);if(!ArrayBuffer.isView(e))throw new TypeError("You can only enqueue array buffer views when using a ReadableByteStreamController");if(!0===IsDetachedBuffer(e.buffer))throw new TypeError("Cannot enqueue a view onto a detached ArrayBuffer");ReadableByteStreamControllerEnqueue(this,e)}error(e){if(!1===IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("error");const r=this._controlledReadableStream;if("readable"!==r._state)throw new TypeError(`The stream is ${r._state} and so cannot be errored`);ReadableByteStreamControllerError(this,e)}[CancelSteps](e){return this._pendingPullIntos.length>0&&(this._pendingPullIntos[0].bytesFilled=0),ResetQueue(this),PromiseInvokeOrNoop(this._underlyingByteSource,"cancel",[e])}[PullSteps](){const e=this._controlledReadableStream;if(this._queueTotalSize>0){const e=this._queue.shift();this._queueTotalSize-=e.byteLength,ReadableByteStreamControllerHandleQueueDrain(this);let r;try{r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}catch(e){return Promise.reject(e)}return Promise.resolve(CreateIterResultObject(r,!1))}const r=this._autoAllocateChunkSize;if(void 0!==r){let e;try{e=new ArrayBuffer(r)}catch(e){return Promise.reject(e)}const t={buffer:e,byteOffset:0,byteLength:r,bytesFilled:0,elementSize:1,ctor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(t)}const t=ReadableStreamAddReadRequest(e);return ReadableByteStreamControllerCallPullIfNeeded(this),t}}

},{"./helpers.js":10,"./queue-with-sizes.js":11,"./utils.js":14,"./writable-stream.js":15,"better-assert":16}],13:[function(_dereq_,module,exports){
"use strict";function IsTransformStream(r){return!!typeIsObject(r)&&!!Object.prototype.hasOwnProperty.call(r,"_transformStreamController")}function TransformStreamError(r,e){verbose("TransformStreamError()"),"readable"===r._readable._state&&ReadableStreamDefaultControllerError(r._readable._readableStreamController,e),TransformStreamErrorWritableAndUnblockWrite(r,e)}function TransformStreamErrorWritableAndUnblockWrite(r,e){WritableStreamDefaultControllerErrorIfNeeded(r._writable._writableStreamController,e),!0===r._backpressure&&TransformStreamSetBackpressure(r,!1)}function TransformStreamSetBackpressure(r,e){verbose(`TransformStreamSetBackpressure() [backpressure = ${e}]`),void 0!==r._backpressureChangePromise&&r._backpressureChangePromise_resolve(),r._backpressureChangePromise=new Promise(e=>{r._backpressureChangePromise_resolve=e}),r._backpressure=e}function IsTransformStreamDefaultController(r){return!!typeIsObject(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledTransformStream")}function TransformStreamDefaultControllerEnqueue(r,e){verbose("TransformStreamDefaultControllerEnqueue()");const t=r._controlledTransformStream,a=t._readable._readableStreamController;if(!1===ReadableStreamDefaultControllerCanCloseOrEnqueue(a))throw new TypeError("Readable side is not in a state that permits enqueue");try{ReadableStreamDefaultControllerEnqueue(a,e)}catch(r){throw TransformStreamErrorWritableAndUnblockWrite(t,r),t._readable._storedError}ReadableStreamDefaultControllerHasBackpressure(a)!==t._backpressure&&TransformStreamSetBackpressure(t,!0)}function TransformStreamDefaultControllerError(r,e){TransformStreamError(r._controlledTransformStream,e)}function TransformStreamDefaultControllerTerminate(r){verbose("TransformStreamDefaultControllerTerminate()");const e=r._controlledTransformStream,t=e._readable._readableStreamController;!0===ReadableStreamDefaultControllerCanCloseOrEnqueue(t)&&ReadableStreamDefaultControllerClose(t),TransformStreamErrorWritableAndUnblockWrite(e,new TypeError("TransformStream terminated"))}function TransformStreamDefaultSinkInvokeTransform(r,e){const t=r._transformStreamController,a=r._transformer,o=a.transform;if(void 0!==o)return Call(o,a,[e,t]);TransformStreamDefaultControllerEnqueue(t,e)}function TransformStreamDefaultSinkTransform(r,e){verbose("TransformStreamDefaultSinkTransform()");const t=r._ownerTransformStream;let a;try{const r=TransformStreamDefaultSinkInvokeTransform(t,e);a=Promise.resolve(r)}catch(r){a=Promise.reject(r)}return a.catch(r=>{throw TransformStreamError(t,r),r})}function defaultControllerBrandCheckException(r){return new TypeError(`TransformStreamDefaultController.prototype.${r} can only be used on a TransformStreamDefaultController`)}function streamBrandCheckException(r){return new TypeError(`TransformStream.prototype.${r} can only be used on a TransformStream`)}const assert=_dereq_("better-assert"),verbose=_dereq_("debug")("streams:transform-stream:verbose"),{Call:Call,InvokeOrNoop:InvokeOrNoop,PromiseInvokeOrNoop:PromiseInvokeOrNoop,typeIsObject:typeIsObject,createDataProperty:createDataProperty}=_dereq_("./helpers.js"),{ReadableStream:ReadableStream,ReadableStreamDefaultControllerClose:ReadableStreamDefaultControllerClose,ReadableStreamDefaultControllerEnqueue:ReadableStreamDefaultControllerEnqueue,ReadableStreamDefaultControllerError:ReadableStreamDefaultControllerError,ReadableStreamDefaultControllerGetDesiredSize:ReadableStreamDefaultControllerGetDesiredSize,ReadableStreamDefaultControllerHasBackpressure:ReadableStreamDefaultControllerHasBackpressure,ReadableStreamDefaultControllerCanCloseOrEnqueue:ReadableStreamDefaultControllerCanCloseOrEnqueue}=_dereq_("./readable-stream.js"),{WritableStream:WritableStream,WritableStreamDefaultControllerErrorIfNeeded:WritableStreamDefaultControllerErrorIfNeeded}=_dereq_("./writable-stream.js");class TransformStream{constructor(r={},e,{size:t,highWaterMark:a=0}={}){if(this._transformer=r,void 0!==r.readableType)throw new RangeError("Invalid readable type specified");if(void 0!==r.writableType)throw new RangeError("Invalid writable type specified");this._transformStreamController=void 0;const o=new TransformStreamDefaultController(this);this._transformStreamController=o;let n;const s=new Promise(r=>{n=r}),l=new TransformStreamDefaultSource(this,s),m={};createDataProperty(m,"size",t),createDataProperty(m,"highWaterMark",a),this._readable=new ReadableStream(l,m);const f=new TransformStreamDefaultSink(this,s);this._writable=new WritableStream(f,e),this._backpressure=void 0,this._backpressureChangePromise=void 0,this._backpressureChangePromise_resolve=void 0,TransformStreamSetBackpressure(this,!0);const i=InvokeOrNoop(r,"start",[o]);n(i)}get readable(){if(!1===IsTransformStream(this))throw streamBrandCheckException("readable");return this._readable}get writable(){if(!1===IsTransformStream(this))throw streamBrandCheckException("writable");return this._writable}}class TransformStreamDefaultController{constructor(r){if(!1===IsTransformStream(r))throw new TypeError("TransformStreamDefaultController can only be constructed with a TransformStream instance");if(void 0!==r._transformStreamController)throw new TypeError("TransformStreamDefaultController instances can only be created by the TransformStream constructor");this._controlledTransformStream=r}get desiredSize(){if(!1===IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("desiredSize");const r=this._controlledTransformStream._readable._readableStreamController;return ReadableStreamDefaultControllerGetDesiredSize(r)}enqueue(r){if(!1===IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("enqueue");TransformStreamDefaultControllerEnqueue(this,r)}error(r){if(!1===IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("error");TransformStreamDefaultControllerError(this,r)}terminate(){if(!1===IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("terminate");TransformStreamDefaultControllerTerminate(this)}}class TransformStreamDefaultSink{constructor(r,e){this._ownerTransformStream=r,this._startPromise=e}start(){return this._startPromise}write(r){verbose("TransformStreamDefaultSink.prototype.write()");const e=this._ownerTransformStream;return!0===e._backpressure?e._backpressureChangePromise.then(()=>{const t=e._writable;if("erroring"===t._state)throw t._storedError;return TransformStreamDefaultSinkTransform(this,r)}):TransformStreamDefaultSinkTransform(this,r)}abort(){const r=new TypeError("Writable side aborted");TransformStreamError(this._ownerTransformStream,r)}close(){verbose("TransformStreamDefaultSink.prototype.close()");const r=this._ownerTransformStream,e=r._readable;return PromiseInvokeOrNoop(r._transformer,"flush",[r._transformStreamController]).then(()=>{if("errored"===e._state)throw e._storedError;const r=e._readableStreamController;!0===ReadableStreamDefaultControllerCanCloseOrEnqueue(r)&&ReadableStreamDefaultControllerClose(r)}).catch(t=>{throw TransformStreamError(r,t),e._storedError})}}class TransformStreamDefaultSource{constructor(r,e){this._ownerTransformStream=r,this._startPromise=e}start(){return this._startPromise}pull(){verbose("TransformStreamDefaultSource.prototype.pull()");const r=this._ownerTransformStream;return TransformStreamSetBackpressure(r,!1),r._backpressureChangePromise}cancel(r){TransformStreamErrorWritableAndUnblockWrite(this._ownerTransformStream,r)}}module.exports={TransformStream:TransformStream};

},{"./helpers.js":10,"./readable-stream.js":12,"./writable-stream.js":15,"better-assert":16,"debug":18}],14:[function(_dereq_,module,exports){
"use strict";const assert=_dereq_("better-assert");exports.rethrowAssertionErrorRejection=(r=>{r&&r.constructor===assert.AssertionError&&setTimeout(()=>{throw r},0)});

},{"better-assert":16}],15:[function(_dereq_,module,exports){
"use strict";function AcquireWritableStreamDefaultWriter(e){return new WritableStreamDefaultWriter(e)}function IsWritableStream(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")}function IsWritableStreamLocked(e){return void 0!==e._writer}function WritableStreamAbort(e,r){const t=e._state;if("closed"===t)return Promise.resolve(void 0);if("errored"===t)return Promise.reject(e._storedError);const i=new TypeError("Requested to abort");if(void 0!==e._pendingAbortRequest)return Promise.reject(i);let o=!1;"erroring"===t&&(o=!0,r=void 0);const a=new Promise((t,i)=>{e._pendingAbortRequest={_resolve:t,_reject:i,_reason:r,_wasAlreadyErroring:o}});return!1===o&&WritableStreamStartErroring(e,i),a}function WritableStreamAddWriteRequest(e){return new Promise((r,t)=>{const i={_resolve:r,_reject:t};e._writeRequests.push(i)})}function WritableStreamDealWithRejection(e,r){"writable"!==e._state?WritableStreamFinishErroring(e):WritableStreamStartErroring(e,r)}function WritableStreamStartErroring(e,r){const t=e._writableStreamController;e._state="erroring",e._storedError=r;const i=e._writer;void 0!==i&&WritableStreamDefaultWriterEnsureReadyPromiseRejected(i,r),!1===WritableStreamHasOperationMarkedInFlight(e)&&!0===t._started&&WritableStreamFinishErroring(e)}function WritableStreamFinishErroring(e){e._state="errored",e._writableStreamController[ErrorSteps]();const r=e._storedError;for(const t of e._writeRequests)t._reject(r);if(e._writeRequests=[],void 0===e._pendingAbortRequest)return void WritableStreamRejectCloseAndClosedPromiseIfNeeded(e);const t=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,!0===t._wasAlreadyErroring)return t._reject(r),void WritableStreamRejectCloseAndClosedPromiseIfNeeded(e);e._writableStreamController[AbortSteps](t._reason).then(()=>{t._resolve(),WritableStreamRejectCloseAndClosedPromiseIfNeeded(e)},r=>{t._reject(r),WritableStreamRejectCloseAndClosedPromiseIfNeeded(e)})}function WritableStreamFinishInFlightWrite(e){e._inFlightWriteRequest._resolve(void 0),e._inFlightWriteRequest=void 0}function WritableStreamFinishInFlightWriteWithError(e,r){e._inFlightWriteRequest._reject(r),e._inFlightWriteRequest=void 0,WritableStreamDealWithRejection(e,r)}function WritableStreamFinishInFlightClose(e){e._inFlightCloseRequest._resolve(void 0),e._inFlightCloseRequest=void 0,"erroring"===e._state&&(e._storedError=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._resolve(),e._pendingAbortRequest=void 0)),e._state="closed";const r=e._writer;void 0!==r&&defaultWriterClosedPromiseResolve(r)}function WritableStreamFinishInFlightCloseWithError(e,r){e._inFlightCloseRequest._reject(r),e._inFlightCloseRequest=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._reject(r),e._pendingAbortRequest=void 0),WritableStreamDealWithRejection(e,r)}function WritableStreamCloseQueuedOrInFlight(e){return void 0!==e._closeRequest||void 0!==e._inFlightCloseRequest}function WritableStreamHasOperationMarkedInFlight(e){return void 0!==e._inFlightWriteRequest||void 0!==e._inFlightCloseRequest}function WritableStreamMarkCloseRequestInFlight(e){e._inFlightCloseRequest=e._closeRequest,e._closeRequest=void 0}function WritableStreamMarkFirstWriteRequestInFlight(e){e._inFlightWriteRequest=e._writeRequests.shift()}function WritableStreamRejectCloseAndClosedPromiseIfNeeded(e){void 0!==e._closeRequest&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const r=e._writer;void 0!==r&&(defaultWriterClosedPromiseReject(r,e._storedError),r._closedPromise.catch(()=>{}))}function WritableStreamUpdateBackpressure(e,r){const t=e._writer;void 0!==t&&r!==e._backpressure&&(!0===r?defaultWriterReadyPromiseReset(t):defaultWriterReadyPromiseResolve(t)),e._backpressure=r}function IsWritableStreamDefaultWriter(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")}function WritableStreamDefaultWriterAbort(e,r){return WritableStreamAbort(e._ownerWritableStream,r)}function WritableStreamDefaultWriterClose(e){const r=e._ownerWritableStream,t=r._state;if("closed"===t||"errored"===t)return Promise.reject(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const i=new Promise((e,t)=>{const i={_resolve:e,_reject:t};r._closeRequest=i});return!0===r._backpressure&&"writable"===t&&defaultWriterReadyPromiseResolve(e),WritableStreamDefaultControllerClose(r._writableStreamController),i}function WritableStreamDefaultWriterCloseWithErrorPropagation(e){const r=e._ownerWritableStream,t=r._state;return!0===WritableStreamCloseQueuedOrInFlight(r)||"closed"===t?Promise.resolve():"errored"===t?Promise.reject(r._storedError):WritableStreamDefaultWriterClose(e)}function WritableStreamDefaultWriterEnsureClosedPromiseRejected(e,r){"pending"===e._closedPromiseState?defaultWriterClosedPromiseReject(e,r):defaultWriterClosedPromiseResetToRejected(e,r),e._closedPromise.catch(()=>{})}function WritableStreamDefaultWriterEnsureReadyPromiseRejected(e,r){"pending"===e._readyPromiseState?defaultWriterReadyPromiseReject(e,r):defaultWriterReadyPromiseResetToRejected(e,r),e._readyPromise.catch(()=>{})}function WritableStreamDefaultWriterGetDesiredSize(e){const r=e._ownerWritableStream,t=r._state;return"errored"===t||"erroring"===t?null:"closed"===t?0:WritableStreamDefaultControllerGetDesiredSize(r._writableStreamController)}function WritableStreamDefaultWriterRelease(e){const r=e._ownerWritableStream,t=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");WritableStreamDefaultWriterEnsureReadyPromiseRejected(e,t),WritableStreamDefaultWriterEnsureClosedPromiseRejected(e,t),r._writer=void 0,e._ownerWritableStream=void 0}function WritableStreamDefaultWriterWrite(e,r){const t=e._ownerWritableStream,i=t._writableStreamController,o=WritableStreamDefaultControllerGetChunkSize(i,r);if(t!==e._ownerWritableStream)return Promise.reject(defaultWriterLockException("write to"));const a=t._state;if("errored"===a)return Promise.reject(t._storedError);if(!0===WritableStreamCloseQueuedOrInFlight(t)||"closed"===a)return Promise.reject(new TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===a)return Promise.reject(t._storedError);const l=WritableStreamAddWriteRequest(t);return WritableStreamDefaultControllerWrite(i,r,o),l}function WritableStreamDefaultControllerClose(e){EnqueueValueWithSize(e,"close",0),WritableStreamDefaultControllerAdvanceQueueIfNeeded(e)}function WritableStreamDefaultControllerGetChunkSize(e,r){const t=e._strategySize;if(void 0===t)return 1;try{return t(r)}catch(r){return WritableStreamDefaultControllerErrorIfNeeded(e,r),1}}function WritableStreamDefaultControllerGetDesiredSize(e){return e._strategyHWM-e._queueTotalSize}function WritableStreamDefaultControllerWrite(e,r,t){const i={chunk:r};try{EnqueueValueWithSize(e,i,t)}catch(r){return void WritableStreamDefaultControllerErrorIfNeeded(e,r)}const o=e._controlledWritableStream;!1===WritableStreamCloseQueuedOrInFlight(o)&&"writable"===o._state&&WritableStreamUpdateBackpressure(o,WritableStreamDefaultControllerGetBackpressure(e)),WritableStreamDefaultControllerAdvanceQueueIfNeeded(e)}function IsWritableStreamDefaultController(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_underlyingSink")}function WritableStreamDefaultControllerAdvanceQueueIfNeeded(e){const r=e._controlledWritableStream;if(!1===e._started)return;if(void 0!==r._inFlightWriteRequest)return;const t=r._state;if("closed"===t||"errored"===t)return;if("erroring"===t)return void WritableStreamFinishErroring(r);if(0===e._queue.length)return;const i=PeekQueueValue(e);"close"===i?WritableStreamDefaultControllerProcessClose(e):WritableStreamDefaultControllerProcessWrite(e,i.chunk)}function WritableStreamDefaultControllerErrorIfNeeded(e,r){"writable"===e._controlledWritableStream._state&&WritableStreamDefaultControllerError(e,r)}function WritableStreamDefaultControllerProcessClose(e){const r=e._controlledWritableStream;WritableStreamMarkCloseRequestInFlight(r),DequeueValue(e),PromiseInvokeOrNoop(e._underlyingSink,"close",[]).then(()=>{WritableStreamFinishInFlightClose(r)},e=>{WritableStreamFinishInFlightCloseWithError(r,e)}).catch(rethrowAssertionErrorRejection)}function WritableStreamDefaultControllerProcessWrite(e,r){const t=e._controlledWritableStream;WritableStreamMarkFirstWriteRequestInFlight(t),PromiseInvokeOrNoop(e._underlyingSink,"write",[r,e]).then(()=>{WritableStreamFinishInFlightWrite(t);const r=t._state;if(DequeueValue(e),!1===WritableStreamCloseQueuedOrInFlight(t)&&"writable"===r){const r=WritableStreamDefaultControllerGetBackpressure(e);WritableStreamUpdateBackpressure(t,r)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(e)},e=>{WritableStreamFinishInFlightWriteWithError(t,e)}).catch(rethrowAssertionErrorRejection)}function WritableStreamDefaultControllerGetBackpressure(e){return WritableStreamDefaultControllerGetDesiredSize(e)<=0}function WritableStreamDefaultControllerError(e,r){WritableStreamStartErroring(e._controlledWritableStream,r)}function streamBrandCheckException(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function defaultWriterBrandCheckException(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function defaultWriterLockException(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function defaultWriterClosedPromiseInitialize(e){e._closedPromise=new Promise((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t,e._closedPromiseState="pending"})}function defaultWriterClosedPromiseInitializeAsRejected(e,r){e._closedPromise=Promise.reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected"}function defaultWriterClosedPromiseInitializeAsResolved(e){e._closedPromise=Promise.resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved"}function defaultWriterClosedPromiseReject(e,r){e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected"}function defaultWriterClosedPromiseResetToRejected(e,r){e._closedPromise=Promise.reject(r),e._closedPromiseState="rejected"}function defaultWriterClosedPromiseResolve(e){e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved"}function defaultWriterReadyPromiseInitialize(e){e._readyPromise=new Promise((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}function defaultWriterReadyPromiseInitializeAsRejected(e,r){e._readyPromise=Promise.reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected"}function defaultWriterReadyPromiseInitializeAsResolved(e){e._readyPromise=Promise.resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled"}function defaultWriterReadyPromiseReject(e,r){e._readyPromise_reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected"}function defaultWriterReadyPromiseReset(e){e._readyPromise=new Promise((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}function defaultWriterReadyPromiseResetToRejected(e,r){e._readyPromise=Promise.reject(r),e._readyPromiseState="rejected"}function defaultWriterReadyPromiseResolve(e){e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled"}const assert=_dereq_("better-assert"),{InvokeOrNoop:InvokeOrNoop,PromiseInvokeOrNoop:PromiseInvokeOrNoop,ValidateAndNormalizeQueuingStrategy:ValidateAndNormalizeQueuingStrategy,typeIsObject:typeIsObject}=_dereq_("./helpers.js"),{rethrowAssertionErrorRejection:rethrowAssertionErrorRejection}=_dereq_("./utils.js"),{DequeueValue:DequeueValue,EnqueueValueWithSize:EnqueueValueWithSize,PeekQueueValue:PeekQueueValue,ResetQueue:ResetQueue}=_dereq_("./queue-with-sizes.js"),StartSteps=Symbol("[[StartSteps]]"),AbortSteps=Symbol("[[AbortSteps]]"),ErrorSteps=Symbol("[[ErrorSteps]]");class WritableStream{constructor(e={},{size:r,highWaterMark:t=1}={}){if(this._state="writable",this._storedError=void 0,this._writer=void 0,this._writableStreamController=void 0,this._writeRequests=[],this._inFlightWriteRequest=void 0,this._closeRequest=void 0,this._inFlightCloseRequest=void 0,this._pendingAbortRequest=void 0,this._backpressure=!1,void 0!==e.type)throw new RangeError("Invalid type is specified");this._writableStreamController=new WritableStreamDefaultController(this,e,r,t),this._writableStreamController[StartSteps]()}get locked(){if(!1===IsWritableStream(this))throw streamBrandCheckException("locked");return IsWritableStreamLocked(this)}abort(e){return!1===IsWritableStream(this)?Promise.reject(streamBrandCheckException("abort")):!0===IsWritableStreamLocked(this)?Promise.reject(new TypeError("Cannot abort a stream that already has a writer")):WritableStreamAbort(this,e)}getWriter(){if(!1===IsWritableStream(this))throw streamBrandCheckException("getWriter");return AcquireWritableStreamDefaultWriter(this)}}module.exports={AcquireWritableStreamDefaultWriter:AcquireWritableStreamDefaultWriter,IsWritableStream:IsWritableStream,IsWritableStreamLocked:IsWritableStreamLocked,WritableStream:WritableStream,WritableStreamAbort:WritableStreamAbort,WritableStreamDefaultControllerErrorIfNeeded:WritableStreamDefaultControllerErrorIfNeeded,WritableStreamDefaultWriterCloseWithErrorPropagation:WritableStreamDefaultWriterCloseWithErrorPropagation,WritableStreamDefaultWriterRelease:WritableStreamDefaultWriterRelease,WritableStreamDefaultWriterWrite:WritableStreamDefaultWriterWrite,WritableStreamCloseQueuedOrInFlight:WritableStreamCloseQueuedOrInFlight};class WritableStreamDefaultWriter{constructor(e){if(!1===IsWritableStream(e))throw new TypeError("WritableStreamDefaultWriter can only be constructed with a WritableStream instance");if(!0===IsWritableStreamLocked(e))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=e,e._writer=this;const r=e._state;if("writable"===r)!1===WritableStreamCloseQueuedOrInFlight(e)&&!0===e._backpressure?defaultWriterReadyPromiseInitialize(this):defaultWriterReadyPromiseInitializeAsResolved(this),defaultWriterClosedPromiseInitialize(this);else if("erroring"===r)defaultWriterReadyPromiseInitializeAsRejected(this,e._storedError),this._readyPromise.catch(()=>{}),defaultWriterClosedPromiseInitialize(this);else if("closed"===r)defaultWriterReadyPromiseInitializeAsResolved(this),defaultWriterClosedPromiseInitializeAsResolved(this);else{const r=e._storedError;defaultWriterReadyPromiseInitializeAsRejected(this,r),this._readyPromise.catch(()=>{}),defaultWriterClosedPromiseInitializeAsRejected(this,r),this._closedPromise.catch(()=>{})}}get closed(){return!1===IsWritableStreamDefaultWriter(this)?Promise.reject(defaultWriterBrandCheckException("closed")):this._closedPromise}get desiredSize(){if(!1===IsWritableStreamDefaultWriter(this))throw defaultWriterBrandCheckException("desiredSize");if(void 0===this._ownerWritableStream)throw defaultWriterLockException("desiredSize");return WritableStreamDefaultWriterGetDesiredSize(this)}get ready(){return!1===IsWritableStreamDefaultWriter(this)?Promise.reject(defaultWriterBrandCheckException("ready")):this._readyPromise}abort(e){return!1===IsWritableStreamDefaultWriter(this)?Promise.reject(defaultWriterBrandCheckException("abort")):void 0===this._ownerWritableStream?Promise.reject(defaultWriterLockException("abort")):WritableStreamDefaultWriterAbort(this,e)}close(){if(!1===IsWritableStreamDefaultWriter(this))return Promise.reject(defaultWriterBrandCheckException("close"));const e=this._ownerWritableStream;return void 0===e?Promise.reject(defaultWriterLockException("close")):!0===WritableStreamCloseQueuedOrInFlight(e)?Promise.reject(new TypeError("cannot close an already-closing stream")):WritableStreamDefaultWriterClose(this)}releaseLock(){if(!1===IsWritableStreamDefaultWriter(this))throw defaultWriterBrandCheckException("releaseLock");void 0!==this._ownerWritableStream&&WritableStreamDefaultWriterRelease(this)}write(e){return!1===IsWritableStreamDefaultWriter(this)?Promise.reject(defaultWriterBrandCheckException("write")):void 0===this._ownerWritableStream?Promise.reject(defaultWriterLockException("write to")):WritableStreamDefaultWriterWrite(this,e)}}class WritableStreamDefaultController{constructor(e,r,t,i){if(!1===IsWritableStream(e))throw new TypeError("WritableStreamDefaultController can only be constructed with a WritableStream instance");if(void 0!==e._writableStreamController)throw new TypeError("WritableStreamDefaultController instances can only be created by the WritableStream constructor");this._controlledWritableStream=e,this._underlyingSink=r,this._queue=void 0,this._queueTotalSize=void 0,ResetQueue(this),this._started=!1;const o=ValidateAndNormalizeQueuingStrategy(t,i);this._strategySize=o.size,this._strategyHWM=o.highWaterMark,WritableStreamUpdateBackpressure(e,WritableStreamDefaultControllerGetBackpressure(this))}error(e){if(!1===IsWritableStreamDefaultController(this))throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");"writable"===this._controlledWritableStream._state&&WritableStreamDefaultControllerError(this,e)}[AbortSteps](e){return PromiseInvokeOrNoop(this._underlyingSink,"abort",[e])}[ErrorSteps](){ResetQueue(this)}[StartSteps](){const e=InvokeOrNoop(this._underlyingSink,"start",[this]),r=this._controlledWritableStream;Promise.resolve(e).then(()=>{this._started=!0,WritableStreamDefaultControllerAdvanceQueueIfNeeded(this)},e=>{this._started=!0,WritableStreamDealWithRejection(r,e)}).catch(rethrowAssertionErrorRejection)}}

},{"./helpers.js":10,"./queue-with-sizes.js":11,"./utils.js":14,"better-assert":16}],16:[function(_dereq_,module,exports){
(function (process){
function assert(e){if(!e){var r=callsite(),s=r[1],t=s.getFileName(),i=s.getLineNumber(),n=(n=fs.readFileSync(t,"utf8")).split("\n")[i-1].match(/assert\((.*)\)/)[1];throw new AssertionError({message:n,stackStartFunction:r[0].getFunction()})}}var AssertionError=_dereq_("assert").AssertionError,callsite=_dereq_("callsite"),fs=_dereq_("fs");module.exports=process.env.NO_ASSERT?function(){}:assert;

}).call(this,_dereq_('_process'))

},{"_process":4,"assert":2,"callsite":17,"fs":3}],17:[function(_dereq_,module,exports){
module.exports=function(){var r=Error.prepareStackTrace;Error.prepareStackTrace=function(r,e){return e};var e=new Error;Error.captureStackTrace(e,arguments.callee);var a=e.stack;return Error.prepareStackTrace=r,a};

},{}],18:[function(_dereq_,module,exports){
(function (process){
function useColors(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))}function formatArgs(e){var o=this.useColors;if(e[0]=(o?"%c":"")+this.namespace+(o?" %c":" ")+e[0]+(o?"%c ":" ")+"+"+exports.humanize(this.diff),o){var C="color: "+this.color;e.splice(1,0,C,"color: inherit");var t=0,r=0;e[0].replace(/%[a-zA-Z%]/g,function(e){"%%"!==e&&(t++,"%c"===e&&(r=t))}),e.splice(r,0,C)}}function log(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function save(e){try{null==e?exports.storage.removeItem("debug"):exports.storage.debug=e}catch(e){}}function load(){var e;try{e=exports.storage.debug}catch(e){}return!e&&"undefined"!=typeof process&&"env"in process&&(e=process.env.DEBUG),e}function localstorage(){try{return window.localStorage}catch(e){}}exports=module.exports=_dereq_("./debug"),exports.log=log,exports.formatArgs=formatArgs,exports.save=save,exports.load=load,exports.useColors=useColors,exports.storage="undefined"!=typeof chrome&&void 0!==chrome.storage?chrome.storage.local:localstorage(),exports.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],exports.formatters.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}},exports.enable(load());

}).call(this,_dereq_('_process'))

},{"./debug":19,"_process":4}],19:[function(_dereq_,module,exports){
function selectColor(e){var r,t=0;for(r in e)t=(t<<5)-t+e.charCodeAt(r),t|=0;return exports.colors[Math.abs(t)%exports.colors.length]}function createDebug(e){function r(){if(r.enabled){var e=r,s=+new Date,o=s-(t||s);e.diff=o,e.prev=t,e.curr=s,t=s;for(var n=new Array(arguments.length),a=0;a<n.length;a++)n[a]=arguments[a];n[0]=exports.coerce(n[0]),"string"!=typeof n[0]&&n.unshift("%O");var p=0;n[0]=n[0].replace(/%([a-zA-Z%])/g,function(r,t){if("%%"===r)return r;p++;var s=exports.formatters[t];if("function"==typeof s){var o=n[p];r=s.call(e,o),n.splice(p,1),p--}return r}),exports.formatArgs.call(e,n),(r.log||exports.log||console.log.bind(console)).apply(e,n)}}var t;return r.namespace=e,r.enabled=exports.enabled(e),r.useColors=exports.useColors(),r.color=selectColor(e),r.destroy=destroy,"function"==typeof exports.init&&exports.init(r),exports.instances.push(r),r}function destroy(){var e=exports.instances.indexOf(this);return-1!==e&&(exports.instances.splice(e,1),!0)}function enable(e){exports.save(e),exports.names=[],exports.skips=[];var r,t=("string"==typeof e?e:"").split(/[\s,]+/),s=t.length;for(r=0;r<s;r++)t[r]&&("-"===(e=t[r].replace(/\*/g,".*?"))[0]?exports.skips.push(new RegExp("^"+e.substr(1)+"$")):exports.names.push(new RegExp("^"+e+"$")));for(r=0;r<exports.instances.length;r++){var o=exports.instances[r];o.enabled=exports.enabled(o.namespace)}}function disable(){exports.enable("")}function enabled(e){if("*"===e[e.length-1])return!0;var r,t;for(r=0,t=exports.skips.length;r<t;r++)if(exports.skips[r].test(e))return!1;for(r=0,t=exports.names.length;r<t;r++)if(exports.names[r].test(e))return!0;return!1}function coerce(e){return e instanceof Error?e.stack||e.message:e}exports=module.exports=createDebug.debug=createDebug.default=createDebug,exports.coerce=coerce,exports.disable=disable,exports.enable=enable,exports.enabled=enabled,exports.humanize=_dereq_("ms"),exports.instances=[],exports.names=[],exports.skips=[],exports.formatters={};

},{"ms":20}],20:[function(_dereq_,module,exports){
function parse(e){if(!((e=String(e)).length>100)){var r=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(e);if(r){var a=parseFloat(r[1]);switch((r[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return a*y;case"days":case"day":case"d":return a*d;case"hours":case"hour":case"hrs":case"hr":case"h":return a*h;case"minutes":case"minute":case"mins":case"min":case"m":return a*m;case"seconds":case"second":case"secs":case"sec":case"s":return a*s;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return a;default:return}}}}function fmtShort(e){return e>=d?Math.round(e/d)+"d":e>=h?Math.round(e/h)+"h":e>=m?Math.round(e/m)+"m":e>=s?Math.round(e/s)+"s":e+"ms"}function fmtLong(e){return plural(e,d,"day")||plural(e,h,"hour")||plural(e,m,"minute")||plural(e,s,"second")||e+" ms"}function plural(s,e,r){if(!(s<e))return s<1.5*e?Math.floor(s/e)+" "+r:Math.ceil(s/e)+" "+r+"s"}var s=1e3,m=60*s,h=60*m,d=24*h,y=365.25*d;module.exports=function(s,e){e=e||{};var r=typeof s;if("string"===r&&s.length>0)return parse(s);if("number"===r&&!1===isNaN(s))return e.long?fmtLong(s):fmtShort(s);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(s))};

},{}]},{},[1])(1)
});
//# sourceMappingURL=polyfill.min.js.map
